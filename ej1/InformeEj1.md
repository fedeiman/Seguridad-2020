#### Ej1
Lo primero que hicimos fue analizar un poco el comportamiento del programa. Primero lo que notamos fue que para el mismo input daba distintos resultados (lo cual nos da una pista de que probablemente se este usando algun tipo de numero random para la codificacion), pero tambien vimos que por cada caracter que introduciamos teniamos 2 caracteres de salida (si la palabra tenia 10 caracteres, el output tenia 20) y que el output parecia estar en hexadecimal ya que solo utilizaba los caracteres "0123456789abcdef". El tema de los dos numeros en hexa a partir de un caracter nos llevo a pensar que probablemente el binario estaba modificando el codigo ascii de cada caracter de alguna forma (un char tiene 8 bits, es decir 2 numeros en hexa son necesarios para representarlos).

Ya con este analisis inicial continuamos con Cutter para hacer el dissasembly y decompilacion del codigo. Una vez que pasamos el binario por el programa vimos que efectivamente se cargaba un buffer con los datos que ingresabamos, se generaba un numero random al que se le hacia un "and" bit a bit con 0xff y luego se hacia un "xor" del resultado y el caracter actual. Esto logramos deducirlo mirando tanto el codigo decompilado como el dissasembly ya que el codigo decompilado tenia varios errores causados por ser un binario PIE (position independent executable). Lo primero que intentamos de hacer fue causar algun tipo de buffer overflow que fuerze a printf a devolver eso (claramente no habiamos entendido bien el ejercicio todavia, lo habiamos entendido como "Como podemos forzar al programa a devolver esto" y no "Cual era el secreto original antes de esta codificacion"). Un amigo luego nos dijo que estabamos entendiendo mal el problema asi que cambiamos nuestro enfoque. Buscando sobre la funcion rand de c encontramos que en teoria con la misma seed el programa siempre devuelve la misma secuencia de numeros aleatorios. Claramente nuestro programa no usaba la misma seed para cada corrida, si no los resultados hubiesen sido iguales con el mismo input. Buscando que se usaba como seed de srand encontramos las siguientes instrucciones en el assembly:

  

0x0000069b lea eax, main ; 0x66c

0x000006a1 mov dword [esp], eax

0x000006a4 call srand ; sym.imp.srand ; void srand(int seed)

  

Aca lo que vemos es que utiliza la instruccion "lea" para calcular la direccion efectiva de la funcion main, como es un binario PIE esta direccion cambia cada vez que se corre el programa. Ahora sabiendo esto podemos probar todas las direcciones de memoria posibles e ir comprobando el checksum hasta conseguir el secreto original. Pero primero veamos que las posibilidades se pueden achicar. Viendo el objdump o el dissasembly sabemos que la fucion main tiene un offset de 0x66c es decir sin importar donde se cargue el programa el final de la direccion de main va a ser 0x0000066c (Esto no estabamos seguros que fuese asi al principio pues indicaria que siempre se carga el programa en multiplos de 1000, es decir no sabiamos si la direccion donde se cargaba podia tener numeros en las ultimos 3 digitos y tal vez el offset se sumaba, para comprobarlo lo corrimos varias veces y con gdb comprobamos que main siempre se encontraba en una direccion que terminaba con "66c"). Esto baja las posibles seeds de **4.294.967.295** a **1.048.576** lo cual es mas facil de bruteforcear. De ahi fue cuestion de armar un programa en c que probara con todas las direeciones de memoria posibles de main como seed de srand y que luego aplicara la transformacion necesaria (xor y and). Una vez que obtenemos el string podemos calcular el hash md5 de ese string y compararlo con el dado para ver si encontramos el secreto o esa direccion de memoria no era. El programa en c que creamos se encuentra en la carpeta ej1 y nos permitio obtener el secreto  "The flag is EKO{bullshit_PIE_over_x86}" luego de usar la direccion "0xF775C66C" como seed de srand. Tuvimos algunos problemas donde el programa se quedaba loopeando si no encontraba el flag y descubrimos que se debia a que 0xFFFFFFFF (la maxima direccion de memoria) tambien es el valor maximo de un unsigned int asi que tuvimos que ajustar el programa acordemente usando unsigned longs donde fue necesario.
