from pygdbmi.gdbcontroller import GdbController
from subprocess import STDOUT, check_output, CalledProcessError
import subprocess
import os
import random
from time import sleep

gdbmi = GdbController()
r = gdbmi.write('file parse')


def gdb(cmd):
    try:
        response = gdbmi.write(cmd, timeout_sec=3)
    except:
        response = ""
    return response

# Only run when crash is already confirmed
def checkEIP():
    response = gdb('info registers')
    try:
        payloads =  [str(r["payload"]) for r in response]
        payload = [r[15:29] for r in payloads if "rip" in r]
        return (payload[0] == "0x7ffff7de8ef3")
    except:
        return True
    
if __name__ == "__main__":
    while True:
        os.popen("pkill parse")
        seed = random.randint(0, 99999)
        ratio = random.uniform(0,0.1)
        cmd = f"zzuf -s {seed} -r {ratio} ./parse mono.bmp"
        try:
            output = check_output(cmd, stderr=STDOUT, timeout=1, shell=True)
        except CalledProcessError:
            process = subprocess.Popen([f'cat mono.bmp | zzuf -cvq -s{seed} -r{ratio} > breaker_{seed}_{ratio}'], shell=True,
                     stdout=subprocess.PIPE, 
                     stderr=subprocess.PIPE)
            sleep(1)
            try:
                gdb(f'r breaker_{seed}_{ratio}')
            except:
                os.remove(f'./breaker_{seed}_{ratio}')
                print("Gdb hang")
                sleep(2)
                continue
            if checkEIP():
                os.remove(f'./breaker_{seed}_{ratio}')
                continue
            print(f"La seed que cambio el EIP fue {seed} con ratio {ratio}")
            break
        except:
            print("unhandled exception.... Passing")
            pass
               








