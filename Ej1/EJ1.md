### Ej 1

Para comenzar el ejercicioo 1 lo primero que hicimos fue descargar zzuf y el parser de bmp. Luego lo que hicimos fue correr el parser de bmps con el archivo mono.bmp para ver como se veia una ejecucion exitosa. Despues fuzzeamos el archivo mono.bmp con zzuf y lo pusimos a correr con las seed entre 0 y 100 para comenzar. El comando que usamos fue `zzuf -c -s 0:100 ./parse mono.bmp`. Asi obtuvimos que con la seed= 7  y  el ratio de fuzzeo por defecto (0.04) el programa crasheaba con un segmentation fault. Analizando con gdb vimos que este se daba al intentar hacer un memcpy. Para obtener mas datos usanmos PwnGdb que nos dejaba ver claramente si el EIP se habia modificado con el fuzzeo. Despues armamos un script en python que iba pasando seed randoms a zzuf y se fijaba con gdb si habia cambiado el EIP. Lo dejamos andando toda la noche y no dio resultado. Por esto decidimos cambiar a AFL que nos parecio una herramienta mucho mas simple de usar (ya que no tuvimos que armar ningun exploit manual nuestro) y encontro un crash que modificaba el EIP relativamente rapido, lo dejamos dos horas andando en dos threads y uno de los crashes modificaba el EIP. Para usar AFL lo unico que hicimos fue modificar el makefile para que compile con el gcc de afl (algo que es recomendado en el [github](https://github.com/google/AFL) para aumentar la performance y luego simplemente lanzamos el fuzzer con `./AFL/afl-fuzz -t 100 -i ./testcase -o ./AFL_OUTPUT ./parse @@` . Luego de correrlo comprobamos cada uno de los crashes que se habian generado con GDB hasta que encontramos uno que habia tenido un segmentation fault debido a un "Invalid $PC address: 0x4040404" Esto claramente indicaba que el EIP estaba apuntando a una direccion no valida. A partir de ahi fue cuestion de buscar en que parte del archivo se encontraba esa direccion en particular. Haciendo un hexdum del archivo con hd vimos que habia varias parates donde se encontraba ese numero asi que lo primero que intentamos fue remplazar todas las apariciones por un numero que nosotros quisieramos y ver si seguia crasheando. Vimos que si lo hacia y analizamos como afectaba el replace a la direccion del EIP. Despues de refinar bien como hacer para que quedara la direccion que queriamos en el EIP (haciendo lo que llamamos la transformacion magica en el codigo porque no analisamos mucho porque hacia falta, solo fuimos tocando hasta que quedo como queriamos) terminamos el script crash_modifier que toma una address de argumento y genera un nuevo archivo new_crash que deja el EIP en la direccion que le pasamos como argumento. (Uso: "crash_modifier.py 48151623" donde 48151623 seria a donde queremos que apunte el EIP)
