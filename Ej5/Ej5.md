### Ej 5
Para este ejercicio lo primero que tuvimos que hacer fue buscar el profile de volatility que funcionara con el sistema operativo de donde se saco la imagen. Esta la conseguimos de el [github de volatilty foundation ](https://github.com/volatilityfoundation/profiles/tree/master/Linux). Luego empezamos a ver que opciones podiamos usar para buscar el rootkit kbeast. El primero que probamos fue `linux_check_fop` cuya descripcion indica que es para detectar rootkits en linux anaalizando operaciones sobre archivos, lamentablemente no nos dio resultado asi que buscamos otras opciones. El primer resultado lo obtuvimos corriendo `linux_check_modules` que analiza si hay modulos de kernel que estan en memoria pero que no se encuentran en la lista de modulos cargados (porque se quitaron a ellos mismos de la lista). Muchos rootkits utilizan este metodo ya que si uno analiza la lista de modulos de kernel no parece haber nada extraño. Este comando ya nos dio la primera señal de que kbeast se encuentra en el sistema ya que nos devolvio un modulo que esta cargado pero no se encuentra en la lista: "ipsecs_kbeast_v1". Esto ya parece ser una señal bastante clara pero veamos un poco mas si encontramos conexiones extrañas o syscalls manipuladas. Para controlar las syscalls podemos utilizar el comando `linux_check_syscall`. Corriendo este comando ya podemos ver que Kbeast ya tiene efectivamente muchisimo control sobre el sistema. Muchas de las syscalls mas utilizadas como write, kill, open, etc aparecen como "HOOKED", Esto quiere decir que kbeast esta interviniendo todas las llamadas que se hacen a esas funciones y puede estarlas logueando, modificando o haciendo mil cosas mas con cada una de ellas. 
Los comandos que probamos anteriormente fueron particularmente los que dieron resultado, a la hora de buscar rootkits muchos mas se pueden utilizar. Como primera aproximacion al problema siempre es una buena idea analizar los proces corriendo con `linux_pslist` (cuando nosotros lo corrimos no vimos nada extraño) y buscar entre los procesos que estaban corriendo a la hora de capturar la imagen si hay alguno que no sea facilmente reconocible (y googlearlo) o si hay algunos con letras y simbolos extraños. Tambien puede ser una buena opcion analizar que conexiones estan hechas con `linux_netstat` para ver que no haya nada sospechoso. Finalmente si lo anterior no dio resultado lo mas porbable es que si hay algun malware sea un rootkit que se esta alojando en el espacio de kernel. Para este tipo de amenazas se pueden usar los comandos como `linux_check_fop`, `linux_check_modules`, `linux_check_syscall` para detectar alteraciones y modificaciones en los modulos de kernel y llamadas a syscalls. En el caso de linux_check_modules no deberian dar ningun resultado ya que ninguna aplicacion con buenas intenciones deberia estarse escondiendo de la lista de modulos de kernel cargados. Y en el caso de las syscalls todas deberia estar apuntando a las direcciones correctas y no estar "Hookeadas". Una pagina que no sirvio muchisimo para entender como actuan los malwares y rootkits y como hace volatility para detectar casos extraños fue [VolatilityLabs](https://volatility-labs.blogspot.com/)  que contiene muchos analisis de malware con volatility.
